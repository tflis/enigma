//! Main binary entry point for enigmaservice implementation.

#![allow(missing_docs)]

// Imports required by this file.
// extern crate <name of this crate>;
extern crate clap;
extern crate crypt_config;
extern crate enigmaservice;
extern crate hyper;
extern crate native_tls;
extern crate openssl;
extern crate swagger;
extern crate tokio_proto;
extern crate tokio_tls;

// Imports required by server library.
// extern crate enigmaservice;
// extern crate swagger;
extern crate chrono;
extern crate futures;
#[macro_use]
extern crate error_chain;

use std::path::PathBuf;

use clap::{App, Arg};
use crypt_config::config::SyncedConfig;
use hyper::server::Http;
use openssl::error::ErrorStack;
use openssl::ssl::{SslAcceptorBuilder, SslMethod};
use openssl::x509::X509_FILETYPE_PEM;
use swagger::auth::AllowAllAuthenticator;
use swagger::EmptyContext;
use tokio_proto::TcpServer;

mod server_lib;

// Builds an SSL implementation for Simple HTTPS from some hard-coded file names
fn ssl() -> Result<SslAcceptorBuilder, ErrorStack> {
    let mut ssl = SslAcceptorBuilder::mozilla_intermediate_raw(SslMethod::tls())?;

    // Server authentication
    ssl.set_private_key_file("server-key.pem", X509_FILETYPE_PEM)?;
    ssl.set_certificate_chain_file("server-chain.pem")?;
    ssl.check_private_key()?;

    Ok(ssl)
}

/// Create custom server, wire it to the autogenerated router,
/// and pass it to the web server.
fn main() {
    let matches = App::new("server")
        .arg(
            Arg::with_name("https")
                .long("https")
                .help("Whether to use HTTPS or not"),
        )
        .get_matches();

    let path = PathBuf::from("/config/config.json");
    let config = SyncedConfig::new(path);

    let service_fn = enigmaservice::server::context::NewAddContext::<_, EmptyContext>::new(
        AllowAllAuthenticator::new(server_lib::NewService::new(config), "cosmo"),
    );

    let addr = "0.0.0.0:3000"
        .parse()
        .expect("Failed to parse bind address");

    if matches.is_present("https") {
        let ssl = ssl().expect("Failed to load SSL keys");
        let builder: native_tls::TlsAcceptorBuilder =
            native_tls::backend::openssl::TlsAcceptorBuilderExt::from_openssl(ssl);
        let tls_acceptor = builder.build().expect("Failed to build TLS acceptor");
        TcpServer::new(
            tokio_tls::proto::Server::new(Http::new(), tls_acceptor),
            addr,
        )
        .serve(service_fn);
    } else {
        // Using HTTP
        TcpServer::new(Http::new(), addr).serve(service_fn);
    }
}
